from api.settings import TELEGRAM_TOKEN, LAST_NAMES, WEEK_DAYS
from api.school33api import School33Api
from aiogram import Bot, types
from aiogram.dispatcher import Dispatcher
from aiogram.utils import executor
from aiogram.utils.markdown import hbold, hunderline
import aioschedule
import asyncio
import copy
from collections import Counter
import datetime
from aiogram.utils.exceptions import ChatNotFound
import homeworks
from notes import get_notes

bot = Bot(token=TELEGRAM_TOKEN, parse_mode='HTML')
dp = Dispatcher(bot)
api = School33Api(skip_update_marks=False)

def get_keyboard():
    keyboard = types.ReplyKeyboardMarkup(resize_keyboard=True)
    button_1 = types.KeyboardButton(text="–û—Ü–µ–Ω–∫–∏")
    keyboard.add(button_1)
    button_2 = "–î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ"
    keyboard.add(button_2)
    button_3 = "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤"
    keyboard.add(button_3)
    button_4 = "–ö–æ–Ω—Å–ø–µ–∫—Ç—ã"
    keyboard.add(button_4)
    return keyboard

def prettify_marks(marks):
    marks = str(marks)
    marks = marks.replace('[', '')
    marks = marks.replace(']', '')
    marks = marks.replace('5', '5Ô∏è‚É£')
    marks = marks.replace('4', '4Ô∏è‚É£')
    marks = marks.replace('3', '3Ô∏è‚É£')
    marks = marks.replace('2', '2Ô∏è‚É£')
    marks = marks.replace('1', '1Ô∏è‚É£')
    marks = marks.replace(', ', '')
    return marks

@dp.message_handler(commands=['start'])
async def process_start_command(message: types.Message):
    await message.answer(f'–ü—Ä–∏–≤–µ—Ç, {message.from_user.first_name}. –¢—ã —É–∂–µ –ø—Ä–æ—á–∏—Ç–∞–ª –æ–ø–∏—Å–∞–Ω–∏–µ –∏ –∑–Ω–∞–µ—à—å, —á–µ–º —è –º–æ–≥—É —Ç–µ–±–µ –ø–æ–º–æ—á—å.\n' 
    + '–ï—Å–ª–∏ –≤–¥—Ä—É–≥ —Ç—ã –Ω–µ –ø—Ä–æ—á–∏—Ç–∞–ª –æ–ø–∏—Å–∞–Ω–∏–µ, —Ç–æ —è —Ç–≤–æ–π —ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω—ã–π –¥–Ω–µ–≤–Ω–∏–∫, –Ω–æ —Ç–æ–ª—å–∫–æ –≤ —Ç–µ–ª–µ–≥—Ä–∞–º–º–µ –∏ –±–æ–ª–µ–µ –∫—Ä—É—Ç–æ–π. \n\n ' +
    "üìç " + hbold(' –ß—Ç–æ —è –º–æ–≥—É?') + '\n'
    + 'üö© –ü—Ä–∏—Å—ã–ª–∞—Ç—å —Ç–≤–æ–∏ –æ—Ü–µ–Ω–∫–∏ –≤ –¥–∞–Ω–Ω–æ–º —Ç—Ä–∏–º–µ—Å—Ç—Ä–µ –ø–æ –∑–∞–ø—Ä–æ—Å—É (–Ω–æ –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ, –≤ –æ—Ç–ª–∏—á–∏–µ –æ—Ç –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–≥–æ –¥–Ω–µ–≤–Ω–∏–∫–∞)' + '\n' +
    'üö© –ü—Ä–∏—Å—ã–ª–∞—Ç—å —Ç–µ–±–µ –Ω–æ–≤—ã–µ –æ—Ü–µ–Ω–∫–∏ –≤ —Ç–æ—Ç –º–æ–º–µ–Ω—Ç, –∫–æ–≥–¥–∞ —Ç—ã –∏—Ö –ø–æ–ª—É—á–∞–µ—à—å.\n' + 
    'üö© –ü—Ä–∏—Å—ã–ª–∞—Ç—å —Ç–µ–±–µ –¥–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å.\n' + 
    'üö© –û—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Ç–µ–±–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤ –Ω–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å.\n\n' + 
    '–° –ø–æ–º–æ—â—å—é –º–µ–Ω—è —Ç—ã —Å–º–æ–∂–µ—à—å –ø–æ–Ω—è—Ç—å, —á—Ç–æ —É —Ç–µ–±—è –ø–æ–ª—É—á–∞–µ—Ç—Å—è –ª—É—á—à–µ,  –∞ —á—Ç–æ —Ö—É–∂–µ.\n\n'
    'üÜò\n–°–ø—Ä–∞–≤–∫–∞: /help', parse_mode='HTML', reply_markup=get_keyboard()
    )

@dp.message_handler(commands=['help'])
async def help_user(message: types.Message):
    await message.answer("""–í–æ—Ç –∫–æ–º–∞–Ω–¥—ã, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ—Å—Ç—É–ø–Ω—ã –Ω–∞—à–µ–º—É –±–æ—Ç—É.
    /get_marks - —É–∑–Ω–∞—Ç—å –æ —Ç–≤–æ–∏—Ö —Ç–µ–∫—É—â–∏—Ö –æ—Ü–µ–Ω–∫–∞—Ö –≤ —ç—Ç–æ–º —Ç—Ä–∏–º–µ—Å—Ç—Ä–µ
    /get_schedule - —É–∑–Ω–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤ –Ω–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
    /get_homework - —É–∑–Ω–∞—Ç—å –¥–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å""", reply_markup=get_keyboard())

@dp.message_handler(lambda message: message.text == "–û—Ü–µ–Ω–∫–∏" or message.text == "/get_marks")
async def send_marks(message: types.Message):
    last_name = LAST_NAMES[str(message.from_id)]
    for st in api.students:
        if st.name.split(' ')[1] == last_name:
            await message.answer('–¢–≤–æ–∏ –æ—Ü–µ–Ω–∫–∏:')
            for subject in st.subjects:
                if subject.marks != []:
                    marks = prettify_marks(subject.marks)
                    await message.answer(f'{subject.name} {subject.average_mark} {marks}', reply_markup=get_keyboard())

@dp.message_handler(lambda message: message.text == "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤" or message.text == "/get_schedule")
async def send_schedule(message: types.Message):
    await message.answer("""–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–æ–≤ —Å–µ–≥–æ–¥–Ω—è:""")
    if datetime.date.today().isoweekday() == 1 or datetime.date.today().isoweekday() == 6:
        await message.answer("1. 8.00-8.40\n2. 8.45-9.25\n3. 9.35-10.15\n4. 10.30-11.10\n5. 11.25-12.05\n6. 12.20-13.00\n7. 13.10-13.50", reply_markup=get_keyboard())
    elif datetime.date.today().isoweekday() != 7:
        await message.answer("1. 8.30-9.15\n2. 9.25-10.10\n3. 10.25-11.10\n4. 11.25-12.10\n5. 12.25-13.10\n6. 13.20-14.05\n7. 14.15-14.55", reply_markup=get_keyboard())

@dp.message_handler(lambda message: message.text == "–ö–æ–Ω—Å–ø–µ–∫—Ç—ã" or message.text == "/get_notes")
async def send_notes(message: types.Message):
    buttons = []
    subjects = []
    notes = await get_notes()
    for note in notes:
        if note is None:
            continue
        subject = note['subject']
        if subject not in subjects:
            subjects.append(subject)
            buttons.append(types.InlineKeyboardButton(subject, callback_data=f'subject{subject}'))
    inline_kb1 = types.InlineKeyboardMarkup().add(*buttons)
    await message.answer("–ü–æ –∫–∞–∫–æ–º—É –ø—Ä–µ–¥–º–µ—Ç—É –í—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Å–ø–µ–∫—Ç—ã?", reply_markup=inline_kb1)

@dp.callback_query_handler(lambda c: c.data and c.data.startswith('subject'))
async def process_callback_homework(callback_query: types.CallbackQuery):
    subject = callback_query.data[7:]
    id = callback_query.from_user.id
    await bot.answer_callback_query(callback_query.id)
    await bot.send_message(id, '–ó–∞–ø–∏—Å–∏:', reply_markup=get_keyboard())
    notes = await get_notes()
    last_date = datetime.date(2000, 1, 1)
    to_send = ''
    for note in notes:
        if note is None:
            continue
        date = datetime.datetime.strptime(note['date'], '%Y-%m-%d').date()
        if subject == note['subject'] and note['is_new'] and date > last_date:
            to_send = note['files']
    for file in to_send:
        await bot.send_photo(id, photo=file['file']['url'], )        

@dp.message_handler(lambda message: message.text == "–î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ" or message.text == "/get_homework")
async def send_homework(message: types.Message):
    isoweekday = datetime.date.today().isoweekday()
    buttons = []
    if isoweekday != 7:
        buttons.append(types.InlineKeyboardButton('–°–µ–≥–æ–¥–Ω—è', callback_data=f'homework{isoweekday}'))
    if isoweekday == 6 or isoweekday == 7:
        for i in range(1, 7):
            buttons.append(types.InlineKeyboardButton(WEEK_DAYS[i], callback_data=f'homework{i}'))
    else:
        for i in range(isoweekday+1, 7):
            buttons.append(types.InlineKeyboardButton(WEEK_DAYS[i], callback_data=f'homework{i}'))
    inline_kb1 = types.InlineKeyboardMarkup().add(*buttons)
    await message.answer("–ù–∞ –∫–∞–∫–æ–π –¥–µ–Ω—å –í—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –¥/–∑?", reply_markup=inline_kb1)

@dp.callback_query_handler(lambda c: c.data and c.data.startswith('homework'))
async def process_callback_homework(callback_query: types.CallbackQuery):
    code = callback_query.data[-1]
    if code.isdigit():
        code = int(code)
    id = callback_query.from_user.id
    isoweekday = datetime.date.today().isoweekday()
    await bot.answer_callback_query(callback_query.id)
    hws = []
    date = datetime.date.today()
    if code == isoweekday:
        hws = await homeworks.get_homework(datetime.date.today())
    else:
        date = datetime.date.today() + datetime.timedelta(days=1)
        while date.isoweekday() != code:
            date += datetime.timedelta(days=1)
        hws = await homeworks.get_homework(date)
    await bot.send_message(id, '–î–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ: '+WEEK_DAYS[date.isoweekday()], reply_markup=get_keyboard())
    if hws == []:
        await bot.send_message(id, '–î–æ–º–∞—à–Ω–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è –Ω–∞ —ç—Ç–æ—Ç –¥–µ–Ω—å –µ—â—ë –Ω–µ—Ç.', reply_markup=get_keyboard())
    for hw in hws:
        await bot.send_message(id, hbold("–ü—Ä–µ–¥–º–µ—Ç: ")+hw['subject']+hbold("\n–ó–∞–¥–∞–Ω–∏–µ: ")+hw['task'], reply_markup=get_keyboard())
        for file in hw['files']:
            if file['name'][-4:] == '.jpg':
                
                await bot.send_photo(id, photo=file['file']['url'], )
            else:
                await bot.send_document(id, document=file['file']['url'])

async def send_if_new_marks():
    students = copy.deepcopy(api.students)
    api.update_marks()
    for i in range(len(api.students)):
        if students[i].subjects != api.students[i].subjects:
            last_name = students[i].name.split(' ')[1]
            id = list(LAST_NAMES.keys())[list(LAST_NAMES.values()).index(last_name)]
            for j in range(len(students[i].subjects), len(api.students[i].subjects)):
                if api.students[i].subjects[j].marks != []:
                    try:
                        await bot.send_message(id, f"–£ —Ç–µ–±—è –Ω–æ–≤—ã–µ –æ—Ü–µ–Ω–∫–∏ –ø–æ –ø—Ä–µ–¥–º–µ—Ç—É {api.students[i].subjects[j].name}: {prettify_marks(api.students[i].subjects[j].marks)}")
                    except ChatNotFound:
                        print(f"Can't send to {id} {last_name}")
                        break
        for j in range(len(students[i].subjects)):
            if students[i].subjects[j].marks != api.students[i].subjects[j].marks:
                last_name = students[i].name.split(' ')[1]
                id = list(LAST_NAMES.keys())[list(LAST_NAMES.values()).index(last_name)]
                try:
                    res = list((Counter(api.students[i].subjects[j].marks) - Counter(students[i].subjects[j].marks)).elements())
                    if res != []:
                        await bot.send_message(id, f"–£ —Ç–µ–±—è –Ω–æ–≤—ã–µ –æ—Ü–µ–Ω–∫–∏ –ø–æ –ø—Ä–µ–¥–º–µ—Ç—É {api.students[i].subjects[j].name}: {prettify_marks(res)}")
                except ChatNotFound:
                    print(f"Can't send to {id} {last_name}")
                    break

async def scheduler():
    aioschedule.every(10).minutes.do(send_if_new_marks)
    while True:
        await aioschedule.run_pending()
        await asyncio.sleep(1)

async def on_startup(_):
    asyncio.create_task(scheduler())

if __name__ == '__main__':
    executor.start_polling(dp, on_startup=on_startup)
